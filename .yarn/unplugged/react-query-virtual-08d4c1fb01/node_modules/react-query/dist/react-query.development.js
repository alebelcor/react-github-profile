(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) :
  (global = global || self, factory(global.ReactQuery = {}, global.React));
}(this, (function (exports, React) { 'use strict';

  React = React && React.hasOwnProperty('default') ? React['default'] : React;

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  // A type of promise-like that resolves synchronously and supports only one observer
  const _Pact = /*#__PURE__*/function () {
    function _Pact() {}

    _Pact.prototype.then = function (onFulfilled, onRejected) {
      const result = new _Pact();
      const state = this.s;

      if (state) {
        const callback = state & 1 ? onFulfilled : onRejected;

        if (callback) {
          try {
            _settle(result, 1, callback(this.v));
          } catch (e) {
            _settle(result, 2, e);
          }

          return result;
        } else {
          return this;
        }
      }

      this.o = function (_this) {
        try {
          const value = _this.v;

          if (_this.s & 1) {
            _settle(result, 1, onFulfilled ? onFulfilled(value) : value);
          } else if (onRejected) {
            _settle(result, 1, onRejected(value));
          } else {
            _settle(result, 2, value);
          }
        } catch (e) {
          _settle(result, 2, e);
        }
      };

      return result;
    };

    return _Pact;
  }(); // Settles a pact synchronously

  function _settle(pact, state, value) {
    if (!pact.s) {
      if (value instanceof _Pact) {
        if (value.s) {
          if (state & 1) {
            state = value.s;
          }

          value = value.v;
        } else {
          value.o = _settle.bind(null, pact, state);
          return;
        }
      }

      if (value && value.then) {
        value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));
        return;
      }

      pact.s = state;
      pact.v = value;
      const observer = pact.o;

      if (observer) {
        observer(pact);
      }
    }
  }
  function _isSettledPact(thenable) {
    return thenable instanceof _Pact && thenable.s & 1;
  } // Converts argument to a function that always returns a Promise

  function _async(f) {
    return function () {
      for (var args = [], i = 0; i < arguments.length; i++) {
        args[i] = arguments[i];
      }

      try {
        return Promise.resolve(f.apply(this, args));
      } catch (e) {
        return Promise.reject(e);
      }
    };
  } // Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)

  function _await(value, then, direct) {
    if (direct) {
      return then ? then(value) : value;
    }

    if (!value || !value.then) {
      value = Promise.resolve(value);
    }

    return then ? value.then(then) : value;
  } // Awaits on a value that may or may not be a Promise, then ignores it

  function _awaitIgnored(value, direct) {
    if (!direct) {
      return value && value.then ? value.then(_empty) : Promise.resolve();
    }
  } // Proceeds after a value has resolved, or proceeds immediately if the value is not thenable

  function _continue(value, then) {
    return value && value.then ? value.then(then) : then(value);
  } // Proceeds after a value has resolved, or proceeds immediately if the value is not thenable
  const _iteratorSymbol = /*#__PURE__*/typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator"; // Asynchronously iterate through an object's values
  const _asyncIteratorSymbol = /*#__PURE__*/typeof Symbol !== "undefined" ? Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")) : "@@asyncIterator"; // Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing

  function _do(body, test) {
    var awaitBody;

    do {
      var result = body();

      if (result && result.then) {
        if (_isSettledPact(result)) {
          result = result.v;
        } else {
          awaitBody = true;
          break;
        }
      }

      var shouldContinue = test();

      if (_isSettledPact(shouldContinue)) {
        shouldContinue = shouldContinue.v;
      }

      if (!shouldContinue) {
        return result;
      }
    } while (!shouldContinue.then);

    const pact = new _Pact();

    const reject = _settle.bind(null, pact, 2);

    (awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);
    return pact;

    function _resumeAfterBody(value) {
      result = value;

      for (;;) {
        shouldContinue = test();

        if (_isSettledPact(shouldContinue)) {
          shouldContinue = shouldContinue.v;
        }

        if (!shouldContinue) {
          break;
        }

        if (shouldContinue.then) {
          shouldContinue.then(_resumeAfterTest).then(void 0, reject);
          return;
        }

        result = body();

        if (result && result.then) {
          if (_isSettledPact(result)) {
            result = result.v;
          } else {
            result.then(_resumeAfterBody).then(void 0, reject);
            return;
          }
        }
      }

      _settle(pact, 1, result);
    }

    function _resumeAfterTest(shouldContinue) {
      if (shouldContinue) {
        do {
          result = body();

          if (result && result.then) {
            if (_isSettledPact(result)) {
              result = result.v;
            } else {
              result.then(_resumeAfterBody).then(void 0, reject);
              return;
            }
          }

          shouldContinue = test();

          if (_isSettledPact(shouldContinue)) {
            shouldContinue = shouldContinue.v;
          }

          if (!shouldContinue) {
            _settle(pact, 1, result);

            return;
          }
        } while (!shouldContinue.then);

        shouldContinue.then(_resumeAfterTest).then(void 0, reject);
      } else {
        _settle(pact, 1, result);
      }
    }
  } // Asynchronously implement a switch statement

  function _invoke(body, then) {
    var result = body();

    if (result && result.then) {
      return result.then(then);
    }

    return then(result);
  } // Asynchronously call a function and swallow the result

  function _invokeIgnored(body) {
    var result = body();

    if (result && result.then) {
      return result.then(_empty);
    }
  } // Asynchronously call a function and send errors to recovery continuation

  function _catch(body, recover) {
    try {
      var result = body();
    } catch (e) {
      return recover(e);
    }

    if (result && result.then) {
      return result.then(void 0, recover);
    }

    return result;
  } // Asynchronously await a promise and pass the result to a finally continuation

  function _finallyRethrows(body, finalizer) {
    try {
      var result = body();
    } catch (e) {
      return finalizer(true, e);
    }

    if (result && result.then) {
      return result.then(finalizer.bind(null, false), finalizer.bind(null, true));
    }

    return finalizer(false, result);
  } // Asynchronously await a promise and invoke a finally continuation that always overrides the result

  function _rethrow(thrown, value) {
    if (thrown) throw value;
    return value;
  } // Empty function to implement break and other control flow that ignores asynchronous results

  function _empty() {} // Sentinel value for early returns in generators

  var statusIdle = 'idle';
  var statusLoading = 'loading';
  var statusError = 'error';
  var statusSuccess = 'success';
  var _uid = 0;
  var uid = function uid() {
    return _uid++;
  };
  var cancelledError = {};
  var isServer = typeof window === 'undefined';
  var noop = function noop() {};
  var identity = function identity(d) {
    return d;
  };
  var Console = console || {
    error: noop,
    warn: noop,
    log: noop
  };
  function useUid() {
    var ref = React.useRef(null);

    if (ref.current === null) {
      ref.current = uid();
    }

    return ref.current;
  }
  function setConsole(c) {
    Console = c;
  }
  function useGetLatest(obj) {
    var ref = React.useRef();
    ref.current = obj;
    return React.useCallback(function () {
      return ref.current;
    }, []);
  }
  function functionalUpdate(updater, old) {
    return typeof updater === 'function' ? updater(old) : updater;
  }
  function stableStringifyReplacer(_, value) {
    return isObject(value) ? Object.assign.apply(Object, [{}].concat(Object.keys(value).sort().map(function (key) {
      var _ref;

      return _ref = {}, _ref[key] = value[key], _ref;
    }))) : value;
  }
  function stableStringify(obj) {
    return JSON.stringify(obj, stableStringifyReplacer);
  }
  function isObject(a) {
    return a && typeof a === 'object' && !Array.isArray(a);
  }
  function deepIncludes(a, b) {
    if (a === b) {
      return true;
    }

    if (typeof a !== typeof b) {
      return false;
    }

    if (typeof a === 'object') {
      return !Object.keys(b).some(function (key) {
        return !deepIncludes(a[key], b[key]);
      });
    }

    return false;
  }
  function isDocumentVisible() {
    return typeof document === 'undefined' || document.visibilityState === undefined || document.visibilityState === 'visible' || document.visibilityState === 'prerender';
  }
  function isOnline() {
    return navigator.onLine === undefined || navigator.onLine;
  }
  function getQueryArgs(args) {
    if (isObject(args[0])) {
      if (args[0].hasOwnProperty('queryKey') && args[0].hasOwnProperty('queryFn')) {
        var _args$ = args[0],
            _queryKey = _args$.queryKey,
            _args$$variables = _args$.variables,
            variables = _args$$variables === void 0 ? [] : _args$$variables,
            _queryFn = _args$.queryFn,
            _args$$config = _args$.config,
            _config = _args$$config === void 0 ? {} : _args$$config;

        return [_queryKey, variables, _queryFn, _config];
      } else {
        throw new Error('queryKey and queryFn keys are required.');
      }
    }

    if (typeof args[2] === 'function') {
      var _queryKey2 = args[0],
          _args$2 = args[1],
          _variables = _args$2 === void 0 ? [] : _args$2,
          _queryFn2 = args[2],
          _args$3 = args[3],
          _config2 = _args$3 === void 0 ? {} : _args$3;

      return [_queryKey2, _variables, _queryFn2, _config2];
    }

    var queryKey = args[0],
        queryFn = args[1],
        _args$4 = args[2],
        config = _args$4 === void 0 ? {} : _args$4;
    return [queryKey, [], queryFn, config];
  }
  function useMountedCallback(callback) {
    var mounted = React.useRef(false);
    React[isServer ? 'useEffect' : 'useLayoutEffect'](function () {
      mounted.current = true;
      return function () {
        return mounted.current = false;
      };
    }, []);
    return React.useCallback(function () {
      return mounted.current ? callback.apply(void 0, arguments) : void 0;
    }, [callback]);
  }
  function handleSuspense(queryInfo) {
    if (queryInfo.config.suspense || queryInfo.config.useErrorBoundary) {
      if (queryInfo.status === statusError) {
        setTimeout(function () {
          queryInfo.query.state.status = 'loading';
        });
        throw queryInfo.error;
      }
    }

    if (queryInfo.config.suspense) {
      if (queryInfo.status === statusLoading) {
        queryInfo.query.wasSuspended = true;
        throw queryInfo.refetch();
      }
    }
  } // This deep-equal is directly based on https://github.com/epoberezkin/fast-deep-equal.
  // The parts for comparing any non-JSON-supported values has been removed

  function deepEqual(a, b) {
    if (a === b) return true;

    if (a && b && typeof a == 'object' && typeof b == 'object') {
      var length, i, keys;

      if (Array.isArray(a)) {
        length = a.length; // eslint-disable-next-line eqeqeq

        if (length != b.length) return false;

        for (i = length; i-- !== 0;) {
          if (!deepEqual(a[i], b[i])) return false;
        }

        return true;
      }

      if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
      keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length) return false;

      for (i = length; i-- !== 0;) {
        if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
      }

      for (i = length; i-- !== 0;) {
        var key = keys[i];
        if (!deepEqual(a[key], b[key])) return false;
      }

      return true;
    } // true if both NaN, false otherwise
    // eslint-disable-next-line no-self-compare


    return a !== a && b !== b;
  }

  var configContext = React.createContext();
  var defaultConfigRef = {
    current: {
      retry: 3,
      retryDelay: function retryDelay(attemptIndex) {
        return Math.min(1000 * Math.pow(2, attemptIndex), 30000);
      },
      staleTime: 0,
      cacheTime: 5 * 60 * 1000,
      refetchAllOnWindowFocus: true,
      refetchInterval: false,
      suspense: false,
      queryKeySerializerFn: defaultQueryKeySerializerFn,
      queryFnParamsFilter: identity,
      throwOnError: false,
      useErrorBoundary: undefined,
      // this will default to the suspense value
      onMutate: noop,
      onSuccess: noop,
      onError: noop,
      onSettled: noop,
      refetchOnMount: true,
      isDataEqual: deepEqual
    }
  };
  function useConfigContext() {
    return React.useContext(configContext) || defaultConfigRef.current;
  }
  function ReactQueryConfigProvider(_ref) {
    var config = _ref.config,
        children = _ref.children;
    var configContextValue = React.useContext(configContext);
    var newConfig = React.useMemo(function () {
      var newConfig = _extends({}, configContextValue || defaultConfigRef.current, {}, config); // Default useErrorBoundary to the suspense value


      if (typeof newConfig.useErrorBoundary === 'undefined') {
        newConfig.useErrorBoundary = newConfig.suspense;
      }

      return newConfig;
    }, [config, configContextValue]);

    if (!configContextValue) {
      defaultConfigRef.current = newConfig;
    }

    return React.createElement(configContext.Provider, {
      value: newConfig
    }, children);
  }
  function defaultQueryKeySerializerFn(queryKey) {
    if (!queryKey) {
      return [];
    }

    if (typeof queryKey === 'function') {
      try {
        return defaultQueryKeySerializerFn(queryKey());
      } catch (_unused) {
        return [];
      }
    }

    if (typeof queryKey === 'string') {
      queryKey = [queryKey];
    }

    var queryHash = stableStringify(queryKey);
    queryKey = JSON.parse(queryHash);
    return [queryHash, queryKey];
  }

  var queryCache = makeQueryCache();
  var queryCacheContext = React.createContext(queryCache);
  var queryCaches = [queryCache];
  function useQueryCache() {
    return React.useContext(queryCacheContext);
  }
  function ReactQueryCacheProvider(_ref) {
    var queryCache = _ref.queryCache,
        children = _ref.children;
    var cache = React.useMemo(function () {
      return queryCache || makeQueryCache();
    }, [queryCache]);
    React.useEffect(function () {
      queryCaches.push(cache);
      return function () {
        // remove the cache from the active list
        var i = queryCaches.indexOf(cache);

        if (i >= 0) {
          queryCaches.splice(i, 1);
        } // if the cache was created by us, we need to tear it down


        if (queryCache == null) {
          cache.clear();
        }
      };
    }, [cache, queryCache]);
    return React.createElement(queryCacheContext.Provider, {
      value: cache
    }, children);
  }
  var actionInit = {};
  var actionFailed = {};
  var actionMarkStale = {};
  var actionMarkGC = {};
  var actionFetch = {};
  var actionSuccess = {};
  var actionError = {};
  var actionSetState = {};
  function makeQueryCache() {
    var listeners = [];
    var cache = {
      queries: {},
      isFetching: 0
    };

    var notifyGlobalListeners = function notifyGlobalListeners() {
      cache.isFetching = Object.values(cache.queries).reduce(function (acc, query) {
        return query.state.isFetching ? acc + 1 : acc;
      }, 0);
      listeners.forEach(function (d) {
        return d(cache);
      });
    };

    cache.subscribe = function (cb) {
      listeners.push(cb);
      return function () {
        listeners.splice(listeners.indexOf(cb), 1);
      };
    };

    cache.clear = function () {
      Object.values(cache.queries).forEach(function (query) {
        return query.clear();
      });
      cache.queries = {};
      notifyGlobalListeners();
    };

    var findQueries = function findQueries(predicate, _temp) {
      var _ref2 = _temp === void 0 ? {} : _temp,
          exact = _ref2.exact;

      if (typeof predicate !== 'function') {
        var _defaultConfigRef$cur = defaultConfigRef.current.queryKeySerializerFn(predicate),
            queryHash = _defaultConfigRef$cur[0],
            queryKey = _defaultConfigRef$cur[1];

        predicate = function predicate(d) {
          return exact ? d.queryHash === queryHash : deepIncludes(d.queryKey, queryKey);
        };
      }

      return Object.values(cache.queries).filter(predicate);
    };

    cache.getQueries = findQueries;

    cache.getQuery = function (queryKey) {
      return findQueries(queryKey, {
        exact: true
      })[0];
    };

    cache.getQueryData = function (queryKey) {
      var _cache$getQuery;

      return (_cache$getQuery = cache.getQuery(queryKey)) == null ? void 0 : _cache$getQuery.state.data;
    };

    cache.removeQueries = function (predicate, _temp2) {
      var _ref3 = _temp2 === void 0 ? {} : _temp2,
          exact = _ref3.exact;

      var foundQueries = findQueries(predicate, {
        exact: exact
      });
      foundQueries.forEach(function (query) {
        clearTimeout(query.staleTimeout);
        delete cache.queries[query.queryHash];
      });

      if (foundQueries.length) {
        notifyGlobalListeners();
      }
    };

    cache.cancelQueries = function (predicate, _temp3) {
      var _ref4 = _temp3 === void 0 ? {} : _temp3,
          exact = _ref4.exact;

      var foundQueries = findQueries(predicate, {
        exact: exact
      });
      foundQueries.forEach(function (query) {
        query.cancel();
      });

      if (foundQueries.length) {
        notifyGlobalListeners();
      }
    };

    cache.refetchQueries = _async(function (predicate, _temp4) {
      var _ref5 = _temp4 === void 0 ? {} : _temp4,
          exact = _ref5.exact,
          throwOnError = _ref5.throwOnError,
          force = _ref5.force;

      var foundQueries = predicate === true ? Object.values(cache.queries) : findQueries(predicate, {
        exact: exact
      });
      return _catch(function () {
        return _await(Promise.all(foundQueries.map(function (query) {
          return query.fetch({
            force: force
          });
        })));
      }, function (err) {
        if (throwOnError) {
          throw err;
        }
      });
    });

    cache._buildQuery = function (userQueryKey, queryVariables, queryFn, config) {
      var _config$queryKeySeria = config.queryKeySerializerFn(userQueryKey),
          queryHash = _config$queryKeySeria[0],
          queryKey = _config$queryKeySeria[1];

      var query = cache.queries[queryHash];

      if (query) {
        Object.assign(query, {
          queryVariables: queryVariables,
          queryFn: queryFn
        });
        query.config = _extends({}, query.config, {}, config);
      } else {
        query = makeQuery({
          cache: cache,
          queryKey: queryKey,
          queryHash: queryHash,
          queryVariables: queryVariables,
          queryFn: queryFn,
          config: config
        }); // If the query started with data, schedule
        // a stale timeout

        if (!isServer && query.state.data) {
          query.scheduleStaleTimeout(); // Simulate a query healing process

          query.heal(); // Schedule for garbage collection in case
          // nothing subscribes to this query

          query.scheduleGarbageCollection();
        }

        if (query.queryHash) {
          if (!isServer) {
            cache.queries[queryHash] = query; // Here, we setTimeout so as to not trigger
            // any setState's in parent components in the
            // middle of the render phase.

            setTimeout(function () {
              notifyGlobalListeners();
            });
          }
        }
      }

      return query;
    };

    cache.prefetchQuery = _async(function () {
      var _exit = false;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var _getQueryArgs = getQueryArgs(args),
          queryKey = _getQueryArgs[0],
          queryVariables = _getQueryArgs[1],
          queryFn = _getQueryArgs[2],
          _getQueryArgs$ = _getQueryArgs[3],
          force = _getQueryArgs$.force,
          config = _objectWithoutPropertiesLoose(_getQueryArgs$, ["force"]);

      config = _extends({}, defaultConfigRef.current, {}, config);

      var query = cache._buildQuery(queryKey, queryVariables, queryFn, config); // Don't prefetch queries that are fresh, unless force is passed


      return _invoke(function () {
        if (query.state.isStale || force) {
          // Trigger a fetch and return the promise
          return _catch(function () {
            return _await(query.fetch({
              force: force
            }), function (res) {
              query.wasPrefetched = true;
              _exit = true;
              return res;
            });
          }, function (err) {
            if (config.throwOnError) {
              throw err;
            }
          });
        }
      }, function (_result3) {
        return _exit ? _result3 : query.state.data;
      });
    });

    cache.setQueryData = function (queryKey, updater, _ref6) {
      if (_ref6 === void 0) {
        _ref6 = {};
      }

      var _ref7 = _ref6,
          exact = _ref7.exact,
          config = _objectWithoutPropertiesLoose(_ref7, ["exact"]);

      var queries = findQueries(queryKey, {
        exact: exact
      });

      if (!queries.length && typeof queryKey !== 'function') {
        queries = [cache._buildQuery(queryKey, undefined, function () {
          return new Promise(noop);
        }, _extends({}, defaultConfigRef.current, {}, config))];
      }

      queries.forEach(function (d) {
        return d.setData(updater);
      });
    };

    function makeQuery(options) {
      var queryCache = options.cache;
      var reducer = options.config.queryReducer || defaultQueryReducer;
      var noQueryHash = typeof options.queryHash === 'undefined';
      var initialData = typeof options.config.initialData === 'function' ? options.config.initialData() : options.config.initialData;
      var hasInitialData = typeof initialData !== 'undefined';
      var isStale = noQueryHash ? true : !hasInitialData;
      var manual = options.config.manual;
      var initialStatus = noQueryHash || manual || hasInitialData ? statusSuccess : statusLoading;

      var query = _extends({}, options, {
        instances: [],
        state: reducer(undefined, {
          type: actionInit,
          initialStatus: initialStatus,
          initialData: initialData,
          hasInitialData: hasInitialData,
          isStale: isStale,
          manual: manual
        })
      });

      var dispatch = function dispatch(action) {
        query.state = reducer(query.state, action);
        query.instances.forEach(function (d) {
          return d.onStateUpdate(query.state);
        });
        notifyGlobalListeners();
      };

      query.scheduleStaleTimeout = function () {
        if (query.config.staleTime === Infinity) {
          return;
        }

        query.staleTimeout = setTimeout(function () {
          if (queryCache.getQuery(query.queryKey)) {
            dispatch({
              type: actionMarkStale
            });
          }
        }, query.config.staleTime);
      };

      query.scheduleGarbageCollection = function () {
        if (query.config.cacheTime === Infinity) {
          return;
        }

        dispatch({
          type: actionMarkGC
        });
        query.cacheTimeout = setTimeout(function () {
          cache.removeQueries(function (d) {
            return d.state.markedForGarbageCollection && d.queryHash === query.queryHash;
          });
        }, typeof query.state.data === 'undefined' && query.state.status !== 'error' ? 0 : query.config.cacheTime);
      };

      query.heal = function () {
        // Stop the query from being garbage collected
        clearTimeout(query.cacheTimeout); // Mark the query as not cancelled

        query.cancelled = null;
      };

      query.cancel = function () {
        query.cancelled = cancelledError;

        if (query.cancelPromises) {
          query.cancelPromises();
        }

        delete query.promise;
        notifyGlobalListeners();
      };

      query.updateInstance = function (instance) {
        var found = query.instances.find(function (d) {
          return d.id === instance.id;
        });

        if (found) {
          Object.assign(found, instance);
        } else {
          found = _extends({
            onStateUpdate: noop
          }, instance);
          query.instances.push(instance);
        }
      };

      query.subscribe = function (instanceId) {
        query.heal(); // Return the unsubscribe function

        return function () {
          query.instances = query.instances.filter(function (d) {
            return d.id !== instanceId;
          });

          if (!query.instances.length) {
            query.cancel(); // Schedule garbage collection

            query.scheduleGarbageCollection();
          }
        };
      }; // Set up the fetch function


      var tryFetchData = _async(function (queryFn) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        return _catch(function () {
          // Perform the query
          var promise = queryFn.apply(void 0, query.config.queryFnParamsFilter(args));

          query.cancelPromises = function () {
            return promise.cancel == null ? void 0 : promise.cancel();
          };

          return _await(promise, function (data) {
            delete query.cancelPromises;
            if (query.cancelled) throw query.cancelled;
            return data;
          });
        }, function (error) {
          var _exit2 = false;
          delete query.cancelPromises;
          if (query.cancelled) throw query.cancelled; // If we fail, increase the failureCount

          dispatch({
            type: actionFailed
          }); // Do we need to retry the request?

          return _invoke(function () {
            if (query.config.retry === true || query.state.failureCount <= query.config.retry || typeof query.config.retry === 'function' && query.config.retry(query.state.failureCount, error)) {
              // Only retry if the document is visible
              if (!isDocumentVisible()) {
                // set this flag to continue fetch retries on focus
                query.shouldContinueRetryOnFocus = true;
                _exit2 = true;
                return new Promise(noop);
              }

              delete query.shouldContinueRetryOnFocus; // Determine the retryDelay

              var delay = functionalUpdate(query.config.retryDelay, query.state.failureCount); // Return a new promise with the retry

              _exit2 = true;
              return _await(new Promise(function (resolve, reject) {
                // Keep track of the retry timeout
                setTimeout(_async(function () {
                  return query.cancelled ? reject(query.cancelled) : _catch(function () {
                    return _await(tryFetchData.apply(void 0, [queryFn].concat(args)), function (data) {
                      if (query.cancelled) return reject(query.cancelled);
                      resolve(data);
                    });
                  }, function (error) {
                    if (query.cancelled) return reject(query.cancelled);
                    reject(error);
                  });
                }), delay);
              }));
            }
          }, function (_result4) {
            if (_exit2) return _result4;
            throw error;
          });
        });
      });

      query.fetch = _async(function (_temp6) {
        var _ref8 = _temp6 === void 0 ? {} : _temp6,
            force = _ref8.force,
            _ref8$__queryFn = _ref8.__queryFn,
            __queryFn = _ref8$__queryFn === void 0 ? query.queryFn : _ref8$__queryFn;

        // Don't refetch fresh queries that don't have a queryHash
        if (!query.queryHash || !query.state.isStale && !force) {
          return;
        } // Create a new promise for the query cache if necessary


        if (!query.promise) {
          query.promise = _async(function () {
            // If there are any retries pending for this query, kill them
            query.cancelled = null;
            var callbackInstances = [].concat(query.instances);

            if (query.wasSuspended) {
              callbackInstances.unshift(query.suspenseInstance);
            }

            return _catch(function () {
              // Set up the query refreshing state
              dispatch({
                type: actionFetch
              }); // Try to fetch

              return _await(tryFetchData.apply(void 0, [__queryFn].concat(query.queryKey, query.queryVariables)), function (data) {
                query.setData(function (old) {
                  return query.config.isDataEqual(old, data) ? old : data;
                });
                callbackInstances.forEach(function (instance) {
                  return instance.onSuccess && instance.onSuccess(query.state.data);
                });
                callbackInstances.forEach(function (instance) {
                  return instance.onSettled && instance.onSettled(query.state.data, null);
                });
                delete query.promise;
                return data;
              });
            }, function (error) {
              dispatch({
                type: actionError,
                cancelled: error === query.cancelled,
                error: error
              });
              delete query.promise;

              if (error !== query.cancelled) {
                callbackInstances.forEach(function (instance) {
                  return instance.onError && instance.onError(error);
                });
                callbackInstances.forEach(function (instance) {
                  return instance.onSettled && instance.onSettled(undefined, error);
                });
                throw error;
              }
            });
          })();
        }

        return query.promise;
      });

      query.setState = function (updater) {
        return dispatch({
          type: actionSetState,
          updater: updater
        });
      };

      query.setData = function (updater) {
        // Set data and mark it as cached
        dispatch({
          type: actionSuccess,
          updater: updater
        }); // Schedule a fresh invalidation!

        clearTimeout(query.staleTimeout);
        query.scheduleStaleTimeout();
      };

      query.clear = function () {
        clearTimeout(query.staleTimeout);
        clearTimeout(query.cacheTimeout);
        query.cancel();
      };

      return query;
    }

    return cache;
  }
  function defaultQueryReducer(state, action) {
    switch (action.type) {
      case actionInit:
        return {
          status: action.initialStatus,
          error: null,
          isFetching: action.hasInitialData || action.manual ? false : action.initialStatus === 'loading',
          canFetchMore: false,
          failureCount: 0,
          isStale: action.isStale,
          markedForGarbageCollection: false,
          data: action.initialData,
          updatedAt: action.hasInitialData ? Date.now() : 0
        };

      case actionFailed:
        return _extends({}, state, {
          failureCount: state.failureCount + 1
        });

      case actionMarkStale:
        return _extends({}, state, {
          isStale: true
        });

      case actionMarkGC:
        {
          return _extends({}, state, {
            markedForGarbageCollection: true
          });
        }

      case actionFetch:
        return _extends({}, state, {
          status: state.status === statusError ? statusLoading : state.status,
          isFetching: true,
          failureCount: 0
        });

      case actionSuccess:
        return _extends({}, state, {
          status: statusSuccess,
          data: functionalUpdate(action.updater, state.data),
          error: null,
          isStale: false,
          isFetching: false,
          canFetchMore: action.canFetchMore,
          updatedAt: Date.now(),
          failureCount: 0
        });

      case actionError:
        return _extends({}, state, {
          isFetching: false,
          isStale: true
        }, !action.cancelled && {
          status: statusError,
          error: action.error
        });

      case actionSetState:
        return functionalUpdate(action.updater, state);

      default:
        throw new Error();
    }
  }

  var visibilityChangeEvent = 'visibilitychange';
  var focusEvent = 'focus';

  var onWindowFocus = function onWindowFocus() {
    var refetchAllOnWindowFocus = defaultConfigRef.current.refetchAllOnWindowFocus;

    if (isDocumentVisible() && isOnline()) {
      queryCaches.forEach(function (queryCache) {
        return queryCache.refetchQueries(function (query) {
          if (!query.instances.length) {
            return false;
          }

          if (query.config.manual === true) {
            return false;
          }

          if (query.shouldContinueRetryOnFocus) {
            // delete promise, so `fetch` will create new one
            delete query.promise;
            return true;
          }

          if (typeof query.config.refetchOnWindowFocus === 'undefined') {
            return refetchAllOnWindowFocus;
          } else {
            return query.config.refetchOnWindowFocus;
          }
        }).catch(Console.error);
      });
    }
  };

  var removePreviousHandler;
  function setFocusHandler(callback) {
    // Unsub the old watcher
    if (removePreviousHandler) {
      removePreviousHandler();
    } // Sub the new watcher


    removePreviousHandler = callback(onWindowFocus);
  }
  setFocusHandler(function (handleFocus) {
    var _window;

    // Listen to visibillitychange and focus
    if (!isServer && ((_window = window) == null ? void 0 : _window.addEventListener)) {
      window.addEventListener(visibilityChangeEvent, handleFocus, false);
      window.addEventListener(focusEvent, handleFocus, false);
      return function () {
        // Be sure to unsubscribe if a new handler is set
        window.removeEventListener(visibilityChangeEvent, handleFocus);
        window.removeEventListener(focusEvent, handleFocus);
      };
    }
  });

  function useIsFetching() {
    var queryCache = useQueryCache();

    var _React$useState = React.useState({}),
        state = _React$useState[0],
        setState = _React$useState[1];

    React.useEffect(function () {
      return queryCache.subscribe(function () {
        return setState({});
      });
    }, []);
    return React.useMemo(function () {
      return state && queryCache.isFetching;
    }, [state]);
  }

  var getDefaultState = function getDefaultState() {
    return {
      status: statusIdle,
      data: undefined,
      error: null
    };
  };

  var actionReset = {};
  var actionLoading = {};
  var actionResolve = {};
  var actionReject = {};

  function mutationReducer(state, action) {
    if (action.type === actionReset) {
      return getDefaultState();
    }

    if (action.type === actionLoading) {
      return {
        status: statusLoading
      };
    }

    if (action.type === actionResolve) {
      return {
        status: statusSuccess,
        data: action.data
      };
    }

    if (action.type === actionReject) {
      return {
        status: statusError,
        error: action.error
      };
    }

    throw new Error();
  }

  function useMutation(mutationFn, config) {
    if (config === void 0) {
      config = {};
    }

    var _React$useReducer = React.useReducer(mutationReducer, null, getDefaultState),
        state = _React$useReducer[0],
        unsafeDispatch = _React$useReducer[1];

    var dispatch = useMountedCallback(unsafeDispatch);
    var getMutationFn = useGetLatest(mutationFn);
    var getConfig = useGetLatest(_extends({}, useConfigContext(), {}, config));
    var latestMutationRef = React.useRef();
    var mutate = React.useCallback(_async(function (variables, _temp) {
      var _ref = _temp === void 0 ? {} : _temp,
          _ref$onSuccess = _ref.onSuccess,
          onSuccess = _ref$onSuccess === void 0 ? noop : _ref$onSuccess,
          _ref$onError = _ref.onError,
          onError = _ref$onError === void 0 ? noop : _ref$onError,
          _ref$onSettled = _ref.onSettled,
          onSettled = _ref$onSettled === void 0 ? noop : _ref$onSettled,
          throwOnError = _ref.throwOnError;

      var config = getConfig();
      var mutationId = uid();
      latestMutationRef.current = mutationId;

      var isLatest = _async(function () {
        return latestMutationRef.current === mutationId;
      });

      dispatch({
        type: actionLoading
      });
      var snapshotValue;
      return _catch(function () {
        return _await(config.onMutate(variables), function (_config$onMutate) {
          snapshotValue = _config$onMutate;
          var data;
          return _invoke(function () {
            if (isLatest()) {
              return _await(getMutationFn()(variables), function (_getMutationFn) {
                data = _getMutationFn;
              });
            }
          }, function () {
            return _invoke(function () {
              if (isLatest()) {
                return _awaitIgnored(onSuccess(data, variables));
              }
            }, function () {
              return _invoke(function () {
                if (isLatest()) {
                  return _awaitIgnored(config.onSuccess(data, variables));
                }
              }, function () {
                return _invoke(function () {
                  if (isLatest()) {
                    return _awaitIgnored(onSettled(data, null, variables));
                  }
                }, function () {
                  return _invoke(function () {
                    if (isLatest()) {
                      return _awaitIgnored(config.onSettled(data, null, variables));
                    }
                  }, function () {
                    if (isLatest()) {
                      dispatch({
                        type: actionResolve,
                        data: data
                      });
                    }

                    return data;
                  });
                });
              });
            });
          });
        });
      }, function (error) {
        return _invoke(function () {
          if (isLatest()) {
            Console.error(error);
            return _awaitIgnored(onError(error, variables, snapshotValue));
          }
        }, function () {
          return _invoke(function () {
            if (isLatest()) {
              return _awaitIgnored(config.onError(error, variables, snapshotValue));
            }
          }, function () {
            return _invoke(function () {
              if (isLatest()) {
                return _awaitIgnored(onSettled(undefined, error, variables, snapshotValue));
              }
            }, function () {
              return _invoke(function () {
                if (isLatest()) {
                  return _awaitIgnored(config.onSettled(undefined, error, variables, snapshotValue));
                }
              }, function () {
                if (isLatest()) {
                  dispatch({
                    type: actionReject,
                    error: error
                  });

                  if (throwOnError != null ? throwOnError : config.throwOnError) {
                    throw error;
                  }
                }
              });
            });
          });
        });
      });
    }), [dispatch, getConfig, getMutationFn]);
    var reset = React.useCallback(function () {
      return dispatch({
        type: actionReset
      });
    }, [dispatch]);
    React.useEffect(function () {
      if (getConfig().useErrorBoundary && state.error) {
        throw state.error;
      }
    }, [getConfig, state.error]);
    return [mutate, _extends({}, state, {
      reset: reset
    })];
  }

  function useBaseQuery(queryKey, queryVariables, queryFn, config) {
    if (config === void 0) {
      config = {};
    }

    var instanceId = useUid();
    config = _extends({}, useConfigContext(), {}, config);
    var queryCache = useQueryCache();
    var queryRef = React.useRef();

    var newQuery = queryCache._buildQuery(queryKey, queryVariables, queryFn, config);

    var useCachedQuery = queryRef.current && typeof queryRef.current.queryHash === 'undefined' && typeof newQuery.queryHash === 'undefined'; // Do not use new query with undefined queryHash, if previous query also had undefined queryHash.
    // Otherwise this will cause infinite loop.

    if (!useCachedQuery) {
      queryRef.current = newQuery;
    }

    var query = queryRef.current;

    var _React$useState = React.useState(),
        unsafeRerender = _React$useState[1];

    var rerender = useMountedCallback(unsafeRerender);
    var getLatestConfig = useGetLatest(config);
    var refetch = React.useCallback(_async(function (_ref) {
      if (_ref === void 0) {
        _ref = {};
      }

      var _ref2 = _ref,
          throwOnError = _ref2.throwOnError,
          rest = _objectWithoutPropertiesLoose(_ref2, ["throwOnError"]);

      return _catch(function () {
        return _await(query.fetch(rest));
      }, function (err) {
        if (throwOnError) {
          throw err;
        }
      });
    }), [query]);
    query.suspenseInstance = {
      onSuccess: function onSuccess(data) {
        return getLatestConfig().onSuccess(data);
      },
      onError: function onError(err) {
        return getLatestConfig().onError(err);
      },
      onSettled: function onSettled(data, err) {
        return getLatestConfig().onSettled(data, err);
      }
    }; // After mount, subscribe to the query

    React.useEffect(function () {
      // Update the instance to the query again, but not as a placeholder
      query.updateInstance({
        id: instanceId,
        onStateUpdate: function onStateUpdate() {
          return rerender({});
        },
        onSuccess: function onSuccess(data) {
          return getLatestConfig().onSuccess(data);
        },
        onError: function onError(err) {
          return getLatestConfig().onError(err);
        },
        onSettled: function onSettled(data, err) {
          return getLatestConfig().onSettled(data, err);
        }
      });
      return query.subscribe(instanceId);
    }, [getLatestConfig, instanceId, query, rerender]);
    React.useEffect(function () {
      // Perform the initial fetch for this query if necessary
      if (!getLatestConfig().manual && // Don't auto fetch if config is set to manual query
      !query.wasPrefetched && // Don't double fetch for prefetched queries
      !query.wasSuspended && // Don't double fetch for suspense
      query.state.isStale && ( // Only refetch if stale
      getLatestConfig().refetchOnMount || query.instances.length === 1)) {
        refetch().catch(Console.error);
      }

      query.wasPrefetched = false;
      query.wasSuspended = false;
    }, [getLatestConfig, query, refetch]); // Handle refetch interval

    React.useEffect(function () {
      var query = queryRef.current;

      if (config.refetchInterval && (!query.currentRefetchInterval || // shorter interval should override previous one
      config.refetchInterval < query.currentRefetchInterval)) {
        query.currentRefetchInterval = config.refetchInterval;
        clearInterval(query.refetchIntervalId);
        query.refetchIntervalId = setInterval(function () {
          if (isDocumentVisible() || config.refetchIntervalInBackground) {
            refetch().catch(Console.error);
          }
        }, config.refetchInterval);
        return function () {
          clearInterval(query.refetchIntervalId);
          delete query.refetchIntervalId;
          delete query.currentRefetchInterval;
        };
      }
    }, [config.refetchInterval, config.refetchIntervalInBackground, refetch]);
    return _extends({}, query.state, {
      config: config,
      query: query,
      refetch: refetch
    });
  }

  function useQuery() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var query = useBaseQuery.apply(void 0, getQueryArgs(args));
    handleSuspense(query);
    return query;
  }

  function usePaginatedQuery() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _getQueryArgs = getQueryArgs(args),
        queryKey = _getQueryArgs[0],
        queryVariables = _getQueryArgs[1],
        queryFn = _getQueryArgs[2],
        _getQueryArgs$ = _getQueryArgs[3],
        config = _getQueryArgs$ === void 0 ? {} : _getQueryArgs$;

    var lastDataRef = React.useRef();

    if (!queryKey) {
      lastDataRef.current = undefined;
    } // If latestData is set, don't use initialData


    if (typeof lastDataRef.current !== 'undefined') {
      delete config.initialData;
    }

    var query = useBaseQuery(queryKey, queryVariables, queryFn, config);
    var latestData = query.data,
        status = query.status;
    React.useEffect(function () {
      if (status === 'success' && typeof latestData !== 'undefined') {
        lastDataRef.current = latestData;
      }
    }, [latestData, status]);
    var resolvedData = latestData;

    if (typeof resolvedData === 'undefined') {
      resolvedData = lastDataRef.current;
    }

    if (typeof resolvedData !== 'undefined') {
      status = 'success';
    }

    handleSuspense(query);
    return _extends({}, query, {
      resolvedData: resolvedData,
      latestData: latestData,
      status: status
    });
  }

  function useInfiniteQuery() {
    var queryInfoRef = React.useRef();

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _getQueryArgs = getQueryArgs(args),
        queryKey = _getQueryArgs[0],
        queryVariables = _getQueryArgs[1],
        queryFn = _getQueryArgs[2],
        _getQueryArgs$ = _getQueryArgs[3],
        config = _getQueryArgs$ === void 0 ? {} : _getQueryArgs$;

    var getFetchMore = config.getFetchMore;
    var getGetFetchMore = useGetLatest(getFetchMore); // The default queryFn will query all pages and map them together

    var originalQueryFn = queryFn;
    queryFn = _async(function () {
      var _interrupt = false;
      var data = [];
      var pageVariables = [].concat(queryInfoRef.current.query.pageVariables);
      var rebuiltPageVariables = [];
      return _continue(_do(function () {
        var args = pageVariables.shift();
        return _invokeIgnored(function () {
          if (!data.length) {
            var _push3 = data.push;
            // the first page query doesn't need to be rebuilt
            return _await(originalQueryFn.apply(void 0, args), function (_originalQueryFn) {
              _push3.call(data, _originalQueryFn);

              rebuiltPageVariables.push(args);
            });
          } else {
            // get an up-to-date cursor based on the previous data set
            var nextCursor = getGetFetchMore()(data[data.length - 1], data); // break early if there's no next cursor
            // otherwise we'll start from the beginning
            // which will cause unwanted duplication

            if (!nextCursor) {
              _interrupt = true;
              return;
            }

            var pageArgs = [].concat(args.slice(0, -1), [nextCursor]);
            var _push4 = data.push;
            return _await(originalQueryFn.apply(void 0, pageArgs), function (_originalQueryFn2) {
              _push4.call(data, _originalQueryFn2);

              rebuiltPageVariables.push(pageArgs);
            });
          }
        });
      }, function () {
        return !_interrupt && !!pageVariables.length;
      }), function () {
        queryInfoRef.current.query.canFetchMore = getGetFetchMore()(data[data.length - 1], data);
        queryInfoRef.current.query.pageVariables = rebuiltPageVariables;
        return data;
      });
    });
    var queryInfo = useBaseQuery(queryKey, queryVariables, queryFn, config);

    if (typeof queryInfo.query.canFetchMore === 'undefined' && typeof queryInfo.data !== 'undefined') {
      queryInfo.query.canFetchMore = getGetFetchMore()(queryInfo.data[queryInfo.data.length - 1], queryInfo.data);
    }

    queryInfoRef.current = queryInfo;
    var refetch = queryInfo.refetch,
        _queryInfo$data = queryInfo.data,
        data = _queryInfo$data === void 0 ? [] : _queryInfo$data,
        canFetchMore = queryInfo.query.canFetchMore; // Here we seed the pageVariabes for the query

    if (!queryInfo.query.pageVariables) {
      queryInfo.query.pageVariables = [[].concat(queryInfo.query.queryKey, queryInfo.query.queryVariables)];
    }

    var fetchMore = React.useCallback(function (fetchMoreInfo) {
      if (fetchMoreInfo === void 0) {
        fetchMoreInfo = queryInfoRef.current.query.canFetchMore;
      }

      return queryInfoRef.current.query.canFetchMore ? refetch({
        force: true,
        __queryFn: _async(function () {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          return _finallyRethrows(function () {
            queryInfoRef.current.query.setState(function (old) {
              return _extends({}, old, {
                isFetchingMore: true
              });
            });
            var newArgs = [].concat(args, [fetchMoreInfo]);
            queryInfoRef.current.query.pageVariables.push(newArgs);
            var _queryInfoRef$current = queryInfoRef.current.data;
            return _await(originalQueryFn.apply(void 0, newArgs), function (_originalQueryFn3) {
              var data = [].concat(_queryInfoRef$current, [_originalQueryFn3]);
              queryInfoRef.current.query.canFetchMore = getGetFetchMore()(data[data.length - 1], data);
              return data;
            });
          }, function (_wasThrown, _result) {
            queryInfoRef.current.query.setState(function (old) {
              return _extends({}, old, {
                isFetchingMore: false
              });
            });
            return _rethrow(_wasThrown, _result);
          });
        })
      }) : void 0;
    }, [getGetFetchMore, originalQueryFn, refetch]);
    handleSuspense(queryInfo);
    return _extends({}, queryInfo, {
      data: data,
      canFetchMore: canFetchMore,
      fetchMore: fetchMore
    });
  }

  exports.ReactQueryCacheProvider = ReactQueryCacheProvider;
  exports.ReactQueryConfigProvider = ReactQueryConfigProvider;
  exports.deepIncludes = deepIncludes;
  exports.makeQueryCache = makeQueryCache;
  exports.queryCache = queryCache;
  exports.setConsole = setConsole;
  exports.setFocusHandler = setFocusHandler;
  exports.stableStringify = stableStringify;
  exports.statusError = statusError;
  exports.statusIdle = statusIdle;
  exports.statusLoading = statusLoading;
  exports.statusSuccess = statusSuccess;
  exports.useInfiniteQuery = useInfiniteQuery;
  exports.useIsFetching = useIsFetching;
  exports.useMutation = useMutation;
  exports.usePaginatedQuery = usePaginatedQuery;
  exports.useQuery = useQuery;
  exports.useQueryCache = useQueryCache;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=react-query.development.js.map
